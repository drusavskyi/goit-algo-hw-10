# Домашнє завдання - порівняння алгоритмів

## Структура
```
goit-algo-hw-10/
├── main-1.py
├── main-2.py
└── README.md
```

---

## Завдання 1: Видача решти

### Реалізовані функції
- `find_coins_greedy(amount)` — жадібний алгоритм, який завжди бере найбільший можливий номінал.
- `find_min_coins(amount)` — алгоритм динамічного програмування, що гарантує мінімальну кількість монет.

### Приклад роботи
```
Сума: 113
Greedy: {50: 2, 10: 1, 2: 1, 1: 1}
DP:     {50: 2, 10: 1, 2: 1, 1: 1}
```

### Порівняння ефективності
| Сума | Greedy, ms | DP, ms |
|------|------------|--------|
| 10   | ≈0.001     | ≈0.002 |
| 100  | ≈0.000     | ≈0.020 |
| 1000 | ≈0.000     | ≈0.200 |
| 5000 | ≈0.000     | ≈1.100 |
| 10000| ≈0.000     | ≈2.100 |

**Висновок:**  
- Жадібний алгоритм працює за `O(k)` і є дуже швидким.  
- Динамічне програмування має складність `O(amount * k)`, тому час зростає з сумою.  
- Для нашої системи монет обидва методи дають однаковий результат, але Greedy значно ефективніший.

---

## Завдання 2: Інтеграл методом Монте-Карло

### Функція
\( f(x) = x^2 \), інтервал інтегрування [0,2].

### Результати
```
Monte Carlo (n=100000): ~2.664500
SciPy quad: 2.666667, похибка ~2.96e-14
```

### Висновок
- Результат методу Монте-Карло дуже близький до точного.  
- Точність залежить від кількості випадкових точок (чим більше n, тим точніше).  
- `quad` дає практично точне значення, але Monte Carlo корисний для складних і багатовимірних інтегралів.

---

## Вимоги
Для запуску потрібні бібліотеки:
```
numpy
matplotlib
scipy
```
Встановлення:
```bash
pip install numpy matplotlib scipy
```
